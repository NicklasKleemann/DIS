# FP-Growth

## FP-Growth (Frequent Pattern Growth)

### Term definition table

| Term | Definition |
| --- | --- |
| FP-Growth | An algorithm for mining **frequent itemsets** without generating candidate sets. |
| FP-Tree | A compressed tree structure that stores transaction data. |
| Header Table | A table linking each item to its occurrences in the FP-Tree. |
| Conditional Pattern Base | Subset of transactions associated with a particular item. |
| Conditional FP-Tree | FP-Tree built from a conditional pattern base. |
| Frequent Itemset | Itemset whose support ≥ minimum support. |
| Support | Fraction of transactions that contain an itemset. |
| Prefix Path | Path in FP-Tree ending in a specific item. |

---

### Definition about the algorithm

**FP-Growth** finds frequent itemsets by building a **compact tree structure (FP-Tree)** that stores all transactions.

It then recursively extracts frequent patterns by exploring **conditional trees**, avoiding expensive candidate generation used in Apriori.

---

### Advantages / disadvantages

**Advantages**

- Much faster than Apriori for large datasets.
- No candidate generation.
- Requires fewer database scans.
- Efficient with dense datasets.

**Disadvantages**

- FP-Tree can become large in memory.
- More complex to implement.
- Harder to parallelize than Apriori.

---

### Math equation

Support is the same as Apriori:

$total transactionssupport(X) = \frac{\text{number of transactions containing } X}{\text{total transactions}}$

---

### Runtime

Let:

- n = number of transactions
- m = number of unique items

**Best / Typical**

$O(n \cdot m)$

**Worst**

$O(2^m)$

(but much faster than Apriori in practice)

---

### Python-like pseudo code

```python
def fp_growth(transactions, min_support):
     fp_tree = build_fp_tree(transactions, min_support)
     patterns = []

 for itemin fp_tree.header_table:
         patterns.append(item)
         conditional_base = find_prefix_paths(fp_tree, item)
         conditional_tree = build_fp_tree(conditional_base, min_support)

 if conditional_treeisnotNone:
             patterns += fp_growth(conditional_base, min_support)

return patterns
```

---

### Step-by-step through the algorithm

1. Scan the database to compute item supports.
2. Remove infrequent items.
3. Sort items in each transaction by descending frequency.
4. Insert transactions into the FP-Tree.
5. Build the header table.
6. For each item in the header table:
    - Find its conditional pattern base.
    - Build a conditional FP-Tree.
    - Recursively mine frequent patterns.
7. Collect all frequent itemsets.