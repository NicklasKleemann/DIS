# FP-Tree

## FP-Tree (Frequent Pattern Tree)

### Term definition table

| Term | Definition |
| --- | --- |
| FP-Tree | A **compact prefix tree** that stores all transactions for frequent pattern mining. |
| Node | Represents an item and its count. |
| Root | Empty node at the top of the tree. |
| Path | A sequence of items from root to a leaf. |
| Header Table | Table that links each item to its first node in the tree. |
| Node Link | Pointer that connects all nodes with the same item. |
| Support Count | Number of transactions represented by a node. |
| Prefix | The items that appear before a given item in a path. |

---

### Definition about the concept

An **FP-Tree** compresses a transaction database by sharing **common prefixes** of transactions.

It allows **FP-Growth** to find frequent patterns efficiently without generating candidate itemsets.

---

### Advantages / disadvantages

**Advantages**

- Much smaller than the raw database.
- Enables fast pattern mining.
- Avoids candidate generation.

**Disadvantages**

- Can be large if data has few common prefixes.
- Complex to build and maintain.

---

### Math equation

Support of an item in FP-Tree:

$support(X) = \sum \text{counts of nodes labeled } X$

---

### Runtime

Let:

- n = number of transactions
- m = number of items

**Building FP-Tree**

- Best & Typical: $O(n \cdot m)$

---

### Python-like pseudo code

```python
def build_fp_tree(transactions, min_support):
     item_counts = count_items(transactions)
     remove itemswith support < min_support
     root = Node(None)

 for tin transactions:
         filtered = sort_by_frequency(t)
         insert_tree(filtered, root)

return root
```

---

### Step-by-step through the concept

1. Scan transactions to compute item supports.
2. Remove infrequent items.
3. Sort remaining items in each transaction by frequency.
4. Insert transactions into the tree.
5. Update counts and node links.
6. Use tree for mining frequent patterns.